<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Attack</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundsEnabled = true;

        // Responsive resize
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game states
        const STATES = { MENU: 'menu', PLAYING: 'playing', PAUSED: 'paused', GAMEOVER: 'gameover' };
        let state = STATES.MENU;

        // Difficulty settings
        const DIFFICULTIES = {
            EASY: { speed: 0.5, wordLength: [2, 4], spawnRate: 3000 },
            NORMAL: { speed: 2, wordLength: [5, 8], spawnRate: 1500 },
            EXPERT: { speed: 3, wordLength: [8, 12], spawnRate: 1000 }
        };
        let difficulty = 'EASY';

        // Word list
        const allWords = 'a,abandon,ability,able,about,above,abroad,absence,absolute,absorb,abuse,accept,access,accident,accompany,accomplish,account,accurate,accuse,achieve,acid,acknowledge,acquire,across,act,action,active,activity,actor,actress,actual,add,address,adjust,admire,adopt,adult,advance,advantage,advice,affair,affect,afford,afraid,after,afternoon,again,against,age,agency,agent,agree,agreement,ago,air,airport,alarm,album,alive,allow,almost,alone,along,already,also,although,always,amazing,among,amount,analysis,ancient,and,anger,animal,answer,anxiety,any,anyone,anything,anyway,apart,apartment,apple,apply,appoint,approach,approval,approve,area,argue,army,around,arrange,arrest,arrive,art,artist,as,ask,aspect,assault,assist,assume,at,athlete,attack,attempt,attend,attention,attitude,attract,audience,author,available,avoid,award,aware,baby,back,bad,bag,balance,ball,bank,bar,base,baseball,basic,basket,bath,battle,be,beach,bear,beat,beautiful,because,become,bed,beer,before,begin,behavior,behind,being,belief,believe,bell,belong,below,best,better,between,beyond,big,bike,bill,bird,birth,bit,black,blade,blame,blanket,blind,block,blood,blue,board,boat,body,bone,book,boom,boss,both,bottle,bottom,bowl,box,boy,brain,branch,brand,bread,break,breakfast,breath,bridge,bright,bring,broad,broken,brother,brown,brush,build,building,burn,business,but,buy,by'.split(',');

        function getWordsByLength(min, max) {
            return allWords.filter(w => w.length >= min && w.length <= max);
        }

        // Game variables
        let player = { x: canvas.width / 2, y: canvas.height - 50, health: 5 };
        let enemies = [];
        let particles = [];
        let lasers = [];
        let stars = [];
        let score = 0;
        let typed = '';
        let targetedEnemy = null;
        let lastSpawn = 0;
        let startTime = null;
        let wordsDestroyed = 0;
        let totalCorrectChars = 0;
        let errorCount = 0;

        for (let i = 0; i < 100; i++) {
            stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 1 });
        }

        // Sounds
        function playSound(freq, duration, type = 'sine') {
            if (!soundsEnabled) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            osc.start();
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.stop(audioCtx.currentTime + duration);
        }
        function playShoot() { playSound(800, 0.1, 'square'); }
        function playExplosion() { playSound(100, 0.3, 'sawtooth'); }
        function playWrong() { playSound(200, 0.1, 'triangle'); }

        function getRandomWord(minLen, maxLen) {
            const filtered = getWordsByLength(minLen, maxLen);
            return filtered[Math.floor(Math.random() * filtered.length)] || 'word';
        }

        // Enemy class
        class Enemy {
            constructor(x, y, word, speed) {
                this.x = x;
                this.y = y;
                this.word = word.toLowerCase();
                this.speed = speed;
                this.size = 30;
            }
            update() {
                this.y += this.speed;
                if (this.y > canvas.height - 50) {
                    player.health--;
                    enemies = enemies.filter(e => e !== this);
                    if (this === targetedEnemy) {
                        typed = '';
                        targetedEnemy = null;
                    }
                    if (player.health <= 0) state = STATES.GAMEOVER;
                }
            }
            draw() {
                ctx.shadowColor = this === targetedEnemy ? '#00ff00' : '#ff00ff';
                ctx.shadowBlur = this === targetedEnemy ? 20 : 15;
                ctx.fillStyle = this === targetedEnemy ? '#00ff00' : '#ff00ff';
                ctx.beginPath();
                const points = 8;
                for (let i = 0; i < points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const r = this.size + Math.random() * 5 - 2.5;
                    const px = this.x + Math.cos(angle) * r;
                    const py = this.y + Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                
                if (this === targetedEnemy) {
                    // Draw the word with a background to make it more readable
                    const textWidth = ctx.measureText(this.word).width;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(this.x - textWidth/2 - 5, this.y - this.size - 25, textWidth + 10, 30);
                    
                    // Draw the original word in white
                    ctx.fillStyle = '#fff';
                    ctx.fillText(this.word, this.x, this.y - this.size - 5);
                    
                    // Draw typed text in cyan below the word
                    ctx.fillStyle = '#00ffff';
                    ctx.fillText(typed, this.x, this.y - this.size - 25);
                } else {
                    // Draw normal word
                    ctx.fillText(this.word, this.x, this.y - this.size - 5);
                }
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = Math.random() * 4 - 2;
                this.vy = Math.random() * 4 - 2;
                this.life = 20;
                this.color = '#ff00ff';
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 2, 2); }
        }

        class Laser {
            constructor(sx, sy, ex, ey) {
                this.startX = sx; this.startY = sy;
                this.endX = ex; this.endY = ey;
                this.life = 10;
            }
            update() { this.life--; }
            draw() {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.stroke();
            }
        }

        function drawStars() {
            ctx.fillStyle = '#fff';
            stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));
        }

        function drawPlayer() {
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - 30);
            ctx.lineTo(player.x - 25, player.y + 20);
            ctx.lineTo(player.x + 25, player.y + 20);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function spawnEnemy() {
            const config = DIFFICULTIES[difficulty];
            const x = Math.random() * (canvas.width - 100) + 50;
            const word = getRandomWord(...config.wordLength);
            enemies.push(new Enemy(x, 0, word, config.speed));
        }

        // Typing
        window.addEventListener('keydown', (e) => {
            if (state === STATES.PAUSED && e.key === 'Escape') { state = STATES.PLAYING; return; }
            if (state !== STATES.PLAYING) return;
            if (e.key === 'Escape') { state = STATES.PAUSED; return; }
            const key = e.key.toLowerCase();
            if (key.length === 1 && key.match(/[a-z]/)) {
                if (!startTime) startTime = Date.now();
                typed += key; checkMatch();
            } else if (e.key === 'Backspace') {
                typed = typed.slice(0, -1); checkMatch();
            } else if (e.key === ' ' || e.key === 'Enter') {
                if (targetedEnemy && typed === targetedEnemy.word) handleEnemyDestroyed(targetedEnemy);
            }
        });

        function checkMatch() {
            if (targetedEnemy) {
                if (!targetedEnemy.word.startsWith(typed)) {
                    errorCount++; typed = ''; targetedEnemy = null; playWrong(); checkMatch();
                }
                return;
            }
            const targets = enemies.filter(e => e.word.startsWith(typed));
            if (targets.length > 0) {
                targets.sort((a, b) => b.y - a.y);
                targetedEnemy = targets[0];
            } else { playWrong(); errorCount++; typed = ''; }
        }

        function handleEnemyDestroyed(enemy) {
            playShoot();
            lasers.push(new Laser(player.x, player.y - 30, enemy.x, enemy.y));
            setTimeout(() => {
                if (soundsEnabled) playExplosion();
                for (let i = 0; i < 10; i++) particles.push(new Particle(enemy.x, enemy.y));
            }, 100);
            enemies = enemies.filter(e => e !== enemy);
            totalCorrectChars += typed.length;
            wordsDestroyed++; 
            // Award more points based on word length and difficulty
            const wordBonus = targetedEnemy.word.length * 5;
            const difficultyMultiplier = difficulty === 'EASY' ? 1 : (difficulty === 'NORMAL' ? 2 : 3);
            score += (10 + wordBonus) * difficultyMultiplier;
            typed = ''; targetedEnemy = null;
        }

        function drawHUD() {
            // Draw score with highlight
            ctx.fillStyle = '#00ffff'; ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left'; 
            ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 10;
            ctx.fillText(`Score: ${score}`, 20, 30);
            ctx.shadowBlur = 0;
            
            // Draw health
            ctx.fillStyle = '#fff'; ctx.font = '20px Arial';
            ctx.textAlign = 'right'; ctx.fillText(`Health: ${player.health}`, canvas.width - 20, 30);
            
            // Draw typed text
            ctx.textAlign = 'center'; ctx.fillText(`Typed: ${typed}`, canvas.width / 2, canvas.height - 20);
        }

        // BUTTON SYSTEM
        function drawButton(text, x, y, mode, isHovered) {
            const w = 300, h = 40;
            const bx = x - w / 2, by = y - h / 2;
            ctx.fillStyle = isHovered ? "#ffaa33" : "#ff9900";
            ctx.fillRect(bx, by, w, h);
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(bx, by, w, h);
            ctx.fillStyle = "#000"; ctx.font = "20px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, x, y);
            return { x: bx, y: by, width: w, height: h, mode };
        }

        let menuButtons = [];
        let mousePos = null;
        canvas.addEventListener("mousemove", e => {
            const r = canvas.getBoundingClientRect();
            mousePos = { x: e.clientX - r.left, y: e.clientY - r.top };
        });

        function drawMenu() {
            drawStars();
            ctx.fillStyle = '#00ffff'; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 20;
            ctx.font = '60px Arial'; ctx.textAlign = 'center';
            ctx.fillText('TYPING ATTACK', canvas.width / 2, canvas.height / 2 - 150);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff'; ctx.font = '30px Arial';
            ctx.fillText('Type to Survive!', canvas.width / 2, canvas.height / 2 - 90);

            menuButtons = [];
            menuButtons.push(drawButton("Play Easy Mode", canvas.width / 2, canvas.height / 2 - 20, "EASY", mousePos && mousePos.y > canvas.height/2-40 && mousePos.y < canvas.height/2));
            menuButtons.push(drawButton("Play Normal Mode", canvas.width / 2, canvas.height / 2 + 40, "NORMAL", mousePos && mousePos.y > canvas.height/2+20 && mousePos.y < canvas.height/2+60));
            menuButtons.push(drawButton("Play Expert Mode", canvas.width / 2, canvas.height / 2 + 100, "EXPERT", mousePos && mousePos.y > canvas.height/2+80 && mousePos.y < canvas.height/2+120));

            ctx.font = '20px Arial'; ctx.fillStyle = '#fff';
            ctx.fillText('Press ESC for menu/pause', canvas.width / 2, canvas.height / 2 + 160);
        }

        function handleClick(e) {
            const r = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - r.left;
            const y = (e.clientY || e.touches[0].clientY) - r.top;
            if (state === STATES.MENU) {
                for (let btn of menuButtons) {
                    if (x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height) {
                        difficulty = btn.mode; startGame();
                    }
                }
            } else if (state === STATES.GAMEOVER) { state = STATES.MENU; }
        }
        canvas.addEventListener('click', handleClick);

        function startGame() {
            state = STATES.PLAYING;
            player.health = 5; score = 0;
            enemies = []; particles = []; lasers = [];
            typed = ''; targetedEnemy = null; lastSpawn = 0;
            startTime = null; wordsDestroyed = 0; totalCorrectChars = 0; errorCount = 0;
        }

        function drawPaused() {
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = '#fff'; ctx.font = '40px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Paused', canvas.width/2, canvas.height/2);
            ctx.font = '20px Arial'; ctx.fillText('Press ESC to resume', canvas.width/2, canvas.height/2+40);
        }

        function drawGameOver() {
            drawStars();
            ctx.fillStyle = '#fff'; ctx.font = '50px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Game Over', canvas.width/2, canvas.height/2-100);
            ctx.font = '30px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2-30);
            let acc = 0, wpm = 0;
            if (startTime) {
                const total = totalCorrectChars + errorCount;
                acc = total > 0 ? Math.round(totalCorrectChars / total * 100) : 0;
                const minutes = (Date.now()-startTime)/60000;
                wpm = minutes > 0 ? Math.round(wordsDestroyed/minutes) : 0;
            }
            ctx.fillText(`Accuracy: ${acc}%`, canvas.width/2, canvas.height/2+10);
            ctx.fillText(`Words Per Minute: ${wpm}`, canvas.width/2, canvas.height/2+50);
            drawButton("Restart Game", canvas.width/2, canvas.height/2+120, "RESTART", false);
        }

        function gameLoop(ts) {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawStars();
            if (state === STATES.PLAYING) {
                const cfg = DIFFICULTIES[difficulty];
                if (ts-lastSpawn > cfg.spawnRate) { spawnEnemy(); lastSpawn = ts; }
                enemies.forEach(e => { e.update(); e.draw(); });
                particles = particles.filter(p=>p.life>0); particles.forEach(p=>{p.update();p.draw();});
                lasers = lasers.filter(l=>l.life>0); lasers.forEach(l=>{l.update();l.draw();});
                drawPlayer(); drawHUD();
            } else if (state === STATES.MENU) drawMenu();
            else if (state === STATES.PAUSED) { enemies.forEach(e=>e.draw()); drawPlayer(); drawHUD(); drawPaused(); }
            else if (state === STATES.GAMEOVER) drawGameOver();
            requestAnimationFrame(gameLoop);
        }
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
